# EMQX Configuration for Argus IQ IoT Platform
# Development environment

# Node name
node {
  name = "argus-emqx@127.0.0.1"
  cookie = "argus_mqtt_cookie"
  data_dir = "/opt/emqx/data"
}

# Cluster configuration (single node for now, will expand in production)
cluster {
  name = argus-iot-cluster
  discovery_strategy = manual
}

# MQTT Listeners
listeners.tcp.default {
  bind = "0.0.0.0:1883"
  max_connections = 10000
  max_conn_rate = 1000
}

listeners.ssl.default {
  bind = "0.0.0.0:8883"
  max_connections = 10000
  max_conn_rate = 1000
  # mTLS will be configured in Week 1 Task 6
  ssl_options {
    verify = verify_none
  }
}

listeners.ws.default {
  bind = "0.0.0.0:8083"
  max_connections = 10000
  websocket.mqtt_path = "/mqtt"
}

# Dashboard
dashboard {
  listeners.http {
    bind = "0.0.0.0:18083"
  }
  default_username = "admin"
  default_password = "argus_dev_mqtt"
}

# Authentication (allow anonymous for now)
authentication = [
  {
    mechanism = "password_based"
    backend = "built_in_database"
    enable = false
  }
]

authorization {
  no_match = allow
  deny_action = disconnect
  cache {
    enable = true
    max_size = 1024
    ttl = 1m
  }
}

# MQTT Protocol Settings
mqtt {
  # Maximum packet size (8MB for chunked messages)
  max_packet_size = 8MB
  # Maximum topic depth
  max_topic_levels = 10
  # Maximum QoS allowed
  max_qos_allowed = 2
  # Retain available
  retain_available = true
  # Session expiry
  max_session_expiry_interval = 2h
  # Keep alive
  max_keepalive = 300
}

# Logging
log {
  console {
    enable = true
    level = info
    time_offset = "system"
  }
  file {
    enable = true
    level = info
    path = "/opt/emqx/log/emqx.log"
    rotation_size = 50MB
    rotation_count = 10
  }
}

# Metrics and Stats
stats {
  enable = true
}

# Broker Configuration
broker {
  # Enable shared subscriptions
  shared_subscription_strategy = random
  # Route batch size
  route_batch_clean = true
}

# System Monitor
sysmon {
  os {
    cpu_check_interval = 60s
    cpu_high_watermark = 80%
    cpu_low_watermark = 60%
    mem_check_interval = 60s
    procmem_high_watermark = 5%
  }
}

# Overload Protection
overload_protection {
  enable = false
  backoff_delay = 1
  backoff_gc = false
  backoff_hibernation = true
}
